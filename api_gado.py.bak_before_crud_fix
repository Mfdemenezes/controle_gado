"""
API REST para Sistema de Controle de Gado de Corte
FastAPI + PostgreSQL
"""

from fastapi import FastAPI, HTTPException, Depends, status, Header
from fastapi.responses import HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime, timedelta, date
import psycopg2
from psycopg2.extras import RealDictCursor
import secrets
import hashlib
import os
from dotenv import load_dotenv

load_dotenv()

# Configura√ß√£o do FastAPI com customiza√ß√£o
app = FastAPI(
    title="üêÆ Controle de Gado API",
    description="""## Sistema de Gest√£o de Rebanho Bovino - Gado de Corte

API REST completa para controle de gado de corte com funcionalidades avan√ßadas.

### üìä Recursos Principais

* **Autentica√ß√£o JWT** - Sistema seguro com tokens
* **Gest√£o de Animais** - Cadastro completo do rebanho
* **Pesagens** - Hist√≥rico com c√°lculo autom√°tico de GMD (Ganho M√©dio Di√°rio)
* **Sanidade** - Vacinas, verm√≠fugos e tratamentos
* **Movimenta√ß√µes** - Controle de pastos e lotes
* **Relat√≥rios** - Performance e an√°lises do rebanho

### üîê Como Usar

1. Fa√ßa login em `/api/auth/login` para obter o token
2. Clique em **Authorize** üîí (topo da p√°gina)
3. Cole o token retornado
4. Teste os endpoints!

### üìù Hist√≥rico de Vers√µes

**v1.0.0** (29/Out/2025)
- ‚úÖ Sistema de autentica√ß√£o com JWT
- ‚úÖ CRUD completo de animais
- ‚úÖ Registro de pesagens com c√°lculo de GMD
- ‚úÖ Controle de sanidade (vacinas, verm√≠fugos)
- ‚úÖ Movimenta√ß√µes entre pastos e lotes
- ‚úÖ Relat√≥rios de performance e resumo
- ‚úÖ Interface PWA mobile-first
- ‚úÖ Deploy com HTTPS via Cloudflare

**Roadmap v1.1.0**
- üîÑ Integra√ß√£o com WhatsApp para alertas
- üîÑ Backup autom√°tico di√°rio
- üîÑ Exporta√ß√£o de relat√≥rios (PDF/Excel)
- üîÑ Dashboard analytics avan√ßado

---
**Desenvolvido com ‚ù§Ô∏è usando FastAPI + PostgreSQL**
    """,
    version="1.0.0",
    contact={
        "name": "Suporte T√©cnico",
        "email": "admin@fazenda.com"
    },
    license_info={
        "name": "Uso Interno",
    },
    openapi_tags=[
        {"name": "üîê Autentica√ß√£o", "description": "Login e logout no sistema"},
        {"name": "üêÆ Animais", "description": "Gest√£o completa do rebanho"},
        {"name": "‚öñÔ∏è Pesagens", "description": "Registro e consulta de pesos"},
        {"name": "üíâ Sanidade", "description": "Vacinas e tratamentos"},
        {"name": "üì¶ Movimenta√ß√µes", "description": "Transfer√™ncias entre pastos/lotes"},
        {"name": "üìç Lotes e Pastos", "description": "Consulta de localiza√ß√µes"},
        {"name": "üìä Relat√≥rios", "description": "An√°lises e estat√≠sticas"},
        {"name": "‚öôÔ∏è Sistema", "description": "Health check e informa√ß√µes"}
    ],
    swagger_ui_parameters={
        "deepLinking": True,
        "displayRequestDuration": True,
        "filter": True,
        "syntaxHighlight.theme": "monokai"
    }
)

# CORS para permitir acesso do mobile
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Em produ√ß√£o, especificar dom√≠nios
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# CSS Customizado Verde Musgo
def custom_swagger_ui_html():
    return """
    <link rel="stylesheet" type="text/css" href="/docs/swagger-ui.css">
    <style>
        /* Tema Verde Musgo para Gado de Corte */
        .swagger-ui .topbar { 
            background: linear-gradient(135deg, #556B2F 0%, #6B8E23 100%) !important;
            border-bottom: 4px solid #4a5e24 !important;
        }
        .swagger-ui .info .title small {
            background: #6B8E23 !important;
            color: white !important;
            padding: 2px 8px !important;
            border-radius: 4px !important;
            font-size: 14px !important;
        }
        .swagger-ui .info .title {
            color: #556B2F !important;
            font-size: 36px !important;
            font-weight: bold !important;
        }
        .swagger-ui .btn.authorize {
            background-color: #6B8E23 !important;
            border-color: #556B2F !important;
        }
        .swagger-ui .btn.execute {
            background-color: #556B2F !important;
        }
        .swagger-ui .btn.execute:hover {
            background-color: #6B8E23 !important;
        }
        .swagger-ui .opblock.opblock-post {
            background: rgba(107, 142, 35, 0.12) !important;
            border-color: #6B8E23 !important;
        }
        .swagger-ui .opblock.opblock-post .opblock-summary-method {
            background: #6B8E23 !important;
        }
        .swagger-ui .opblock.opblock-get {
            background: rgba(85, 107, 47, 0.08) !important;
            border-color: #556B2F !important;
        }
        .swagger-ui .opblock.opblock-get .opblock-summary-method {
            background: #556B2F !important;
        }
        .swagger-ui .scheme-container {
            background: #f5f8f0 !important;
            border: 1px solid #d0d8c0 !important;
        }
        .swagger-ui a { color: #556B2F !important; }
        .swagger-ui .opblock-tag { border-bottom: 2px solid #556B2F !important; }
    </style>
    """

app.add_route("/swagger-custom-css", lambda: HTMLResponse(content=custom_swagger_ui_html()), include_in_schema=False)



security = HTTPBearer()

# Configura√ß√µes do banco de dados
DB_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': os.getenv('DB_PORT', '5432'),
    'database': os.getenv('DB_NAME', 'controle_gado'),
    'user': os.getenv('DB_USER', 'postgres'),
    'password': os.getenv('DB_PASSWORD', 'postgres')
}

# ==================== MODELOS PYDANTIC ====================

class LoginRequest(BaseModel):
    email: str
    senha: str

class LoginResponse(BaseModel):
    token: str
    usuario: dict
    expires_at: str

class AnimalCreate(BaseModel):
    brinco: str
    nome: Optional[str] = None
    sexo: str = Field(..., pattern="^[MF]$")
    raca: Optional[str] = None
    data_nascimento: Optional[str] = None
    peso_nascimento: Optional[float] = None
    peso_atual: float
    lote: Optional[str] = None
    pasto: Optional[str] = None
    origem: Optional[str] = None
    valor_compra: Optional[float] = None
    observacoes: Optional[str] = None

class AnimalUpdate(BaseModel):
    nome: Optional[str] = None
    peso_atual: Optional[float] = None
    lote: Optional[str] = None
    pasto: Optional[str] = None
    status: Optional[str] = None
    observacoes: Optional[str] = None

class PesagemCreate(BaseModel):
    animal_id: int
    peso: float
    data_pesagem: Optional[str] = None
    condicao_corporal: Optional[int] = Field(None, ge=1, le=5)
    observacoes: Optional[str] = None

class SanidadeCreate(BaseModel):
    animal_id: int
    tipo: str
    produto: str
    dose: Optional[str] = None
    aplicador: Optional[str] = None
    data_aplicacao: Optional[str] = None
    proxima_aplicacao: Optional[str] = None
    custo: Optional[float] = None
    observacoes: Optional[str] = None

class MovimentacaoCreate(BaseModel):
    animal_id: int
    tipo: str
    origem: Optional[str] = None
    destino: Optional[str] = None
    motivo: Optional[str] = None
    responsavel: Optional[str] = None
    data_movimentacao: Optional[str] = None

# ==================== FUN√á√ïES DE BANCO DE DADOS ====================

def get_db_connection():
    """Cria conex√£o com o banco de dados"""
    try:
        conn = psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)
        return conn
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao conectar no banco: {str(e)}")

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verifica se o token √© v√°lido"""
    token = credentials.credentials
    
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT s.*, u.nome, u.email, u.nivel_acesso
            FROM sessoes s
            INNER JOIN usuarios u ON s.usuario_id = u.id
            WHERE s.token = %s 
            AND s.expires_at > NOW()
            AND u.ativo = TRUE
        """, (token,))
        
        sessao = cur.fetchone()
        
        if not sessao:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token inv√°lido ou expirado"
            )
        
        return dict(sessao)
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE AUTENTICA√á√ÉO ====================

@app.post("/api/auth/login", tags=["üîê Autentica√ß√£o"], response_model=LoginResponse)
def login(credentials: LoginRequest):
    """Endpoint de login"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        # Busca usu√°rio
        cur.execute("""
            SELECT id, nome, email, senha_hash, nivel_acesso, ativo
            FROM usuarios
            WHERE email = %s
        """, (credentials.email,))
        
        usuario = cur.fetchone()
        
        if not usuario or not usuario['ativo']:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Credenciais inv√°lidas"
            )
        
        # Verifica senha (em produ√ß√£o usar bcrypt)
        senha_hash = hashlib.sha256(credentials.senha.encode()).hexdigest()
        
        if usuario['senha_hash'] != senha_hash:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Credenciais inv√°lidas"
            )
        
        # Gera token
        token = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(days=30)
        
        # Salva sess√£o
        cur.execute("""
            INSERT INTO sessoes (usuario_id, token, expires_at)
            VALUES (%s, %s, %s)
            RETURNING id
        """, (usuario['id'], token, expires_at))
        
        conn.commit()
        
        # Atualiza √∫ltimo acesso
        cur.execute("""
            UPDATE usuarios 
            SET ultimo_acesso = NOW() 
            WHERE id = %s
        """, (usuario['id'],))
        
        conn.commit()
        
        return {
            "token": token,
            "usuario": {
                "id": usuario['id'],
                "nome": usuario['nome'],
                "email": usuario['email'],
                "nivel_acesso": usuario['nivel_acesso']
            },
            "expires_at": expires_at.isoformat()
        }
    
    finally:
        cur.close()
        conn.close()

@app.post("/api/auth/logout", tags=["üîê Autentica√ß√£o"])
def logout(user_data: dict = Depends(verify_token)):
    """Endpoint de logout"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            DELETE FROM sessoes 
            WHERE usuario_id = %s
        """, (user_data['usuario_id'],))
        
        conn.commit()
        
        return {"message": "Logout realizado com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE ANIMAIS ====================

@app.get("/api/animais", tags=["üêÆ Animais"])
def listar_animais(
    status: Optional[str] = "ativo",
    lote: Optional[str] = None,
    pasto: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
    user_data: dict = Depends(verify_token)
):
    """Lista animais com filtros"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        query = "SELECT * FROM vw_rebanho_ativo WHERE 1=1"
        params = []
        
        if status:
            query += " AND status = %s"
            params.append(status)
        
        if lote:
            query += " AND lote = %s"
            params.append(lote)
        
        if pasto:
            query += " AND pasto = %s"
            params.append(pasto)
        
        query += " ORDER BY brinco LIMIT %s OFFSET %s"
        params.extend([limit, offset])
        
        cur.execute(query, params)
        animais = cur.fetchall()
        
        return {
            "total": len(animais),
            "data": [dict(animal) for animal in animais]
        }
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/animais/{animal_id}", tags=["üêÆ Animais"])
def buscar_animal(animal_id: int, user_data: dict = Depends(verify_token)):
    """Busca animal por ID"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT * FROM vw_rebanho_ativo WHERE id = %s", (animal_id,))
        animal = cur.fetchone()
        
        if not animal:
            raise HTTPException(status_code=404, detail="Animal n√£o encontrado")
        
        return dict(animal)
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/animais/brinco/{brinco}", tags=["üêÆ Animais"])
def buscar_animal_por_brinco(brinco: str, user_data: dict = Depends(verify_token)):
    """Busca animal por n√∫mero do brinco"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT * FROM vw_rebanho_ativo WHERE brinco = %s", (brinco,))
        animal = cur.fetchone()
        
        if not animal:
            raise HTTPException(status_code=404, detail="Animal n√£o encontrado")
        
        return dict(animal)
    
    finally:
        cur.close()
        conn.close()

@app.post("/api/animais", tags=["üêÆ Animais"], status_code=status.HTTP_201_CREATED)
def cadastrar_animal(animal: AnimalCreate, user_data: dict = Depends(verify_token)):
    """Cadastra novo animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            INSERT INTO animais (
                brinco, nome, sexo, raca, data_nascimento, peso_nascimento,
                peso_atual, lote, pasto, origem, valor_compra, observacoes
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            animal.brinco, animal.nome, animal.sexo, animal.raca,
            animal.data_nascimento, animal.peso_nascimento, animal.peso_atual,
            animal.lote, animal.pasto, animal.origem, animal.valor_compra,
            animal.observacoes
        ))
        
        animal_id = cur.fetchone()['id']
        conn.commit()
        
        # Registra pesagem inicial
        cur.execute("""
            INSERT INTO pesagens (animal_id, peso, observacoes)
            VALUES (%s, %s, %s)
        """, (animal_id, animal.peso_atual, 'Pesagem inicial - cadastro'))
        
        conn.commit()
        
        return {"id": animal_id, "message": "Animal cadastrado com sucesso"}
    
    except psycopg2.IntegrityError as e:
        conn.rollback()
        if 'unique' in str(e).lower():
            raise HTTPException(status_code=400, detail="Brinco j√° cadastrado")
        raise HTTPException(status_code=400, detail=str(e))
    
    finally:
        cur.close()
        conn.close()

@app.put("/api/animais/{animal_id}", tags=["üêÆ Animais"])
def atualizar_animal(
    animal_id: int,
    animal: AnimalUpdate,
    user_data: dict = Depends(verify_token)
):
    """Atualiza dados do animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        # Monta query din√¢mica com campos n√£o nulos
        updates = []
        params = []
        
        for field, value in animal.dict(exclude_unset=True).items():
            if value is not None:
                updates.append(f"{field} = %s")
                params.append(value)
        
        if not updates:
            raise HTTPException(status_code=400, detail="Nenhum campo para atualizar")
        
        params.append(animal_id)
        query = f"UPDATE animais SET {', '.join(updates)} WHERE id = %s"
        
        cur.execute(query, params)
        conn.commit()
        
        if cur.rowcount == 0:
            raise HTTPException(status_code=404, detail="Animal n√£o encontrado")
        
        return {"message": "Animal atualizado com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE PESAGENS ====================

@app.get("/api/pesagens/{animal_id}", tags=["‚öñÔ∏è Pesagens"])
def listar_pesagens(animal_id: int, user_data: dict = Depends(verify_token)):
    """Lista pesagens de um animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT * FROM pesagens 
            WHERE animal_id = %s 
            ORDER BY data_pesagem DESC
        """, (animal_id,))
        
        pesagens = cur.fetchall()
        
        return {
            "total": len(pesagens),
            "data": [dict(p) for p in pesagens]
        }
    
    finally:
        cur.close()
        conn.close()

@app.post("/api/pesagens", tags=["‚öñÔ∏è Pesagens"], status_code=status.HTTP_201_CREATED)
def registrar_pesagem(pesagem: PesagemCreate, user_data: dict = Depends(verify_token)):
    """Registra nova pesagem"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        data_pesagem = pesagem.data_pesagem or datetime.now().date().isoformat()
        
        cur.execute("""
            INSERT INTO pesagens (
                animal_id, peso, data_pesagem, condicao_corporal, observacoes
            ) VALUES (%s, %s, %s, %s, %s)
            RETURNING id
        """, (
            pesagem.animal_id, pesagem.peso, data_pesagem,
            pesagem.condicao_corporal, pesagem.observacoes
        ))
        
        pesagem_id = cur.fetchone()['id']
        
        # Atualiza peso atual do animal
        cur.execute("""
            UPDATE animais 
            SET peso_atual = %s 
            WHERE id = %s
        """, (pesagem.peso, pesagem.animal_id))
        
        conn.commit()
        
        return {"id": pesagem_id, "message": "Pesagem registrada com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE SANIDADE ====================

@app.post("/api/sanidade", tags=["üíâ Sanidade"], status_code=status.HTTP_201_CREATED)
def registrar_sanidade(sanidade: SanidadeCreate, user_data: dict = Depends(verify_token)):
    """Registra aplica√ß√£o de sanidade"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        data_aplicacao = sanidade.data_aplicacao or datetime.now().date().isoformat()
        
        cur.execute("""
            INSERT INTO sanidade (
                animal_id, tipo, produto, dose, aplicador,
                data_aplicacao, proxima_aplicacao, custo, observacoes
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            sanidade.animal_id, sanidade.tipo, sanidade.produto, sanidade.dose,
            sanidade.aplicador, data_aplicacao, sanidade.proxima_aplicacao,
            sanidade.custo, sanidade.observacoes
        ))
        
        sanidade_id = cur.fetchone()['id']
        conn.commit()
        
        return {"id": sanidade_id, "message": "Sanidade registrada com sucesso"}
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/sanidade/proximas", tags=["üíâ Sanidade"])
def listar_proximas_aplicacoes(dias: int = 30, user_data: dict = Depends(verify_token)):
    """Lista pr√≥ximas aplica√ß√µes programadas"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT * FROM vw_aplicacoes_proximas 
            WHERE dias_restantes <= %s
            ORDER BY proxima_aplicacao
        """, (dias,))
        
        aplicacoes = cur.fetchall()
        
        return {
            "total": len(aplicacoes),
            "data": [dict(a) for a in aplicacoes]
        }
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE RELAT√ìRIOS ====================

@app.get("/api/relatorios/resumo", tags=["üìä Relat√≥rios"])
def relatorio_resumo(user_data: dict = Depends(verify_token)):
    """Relat√≥rio resumo do rebanho"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT * FROM vw_resumo_rebanho")
        resumo = cur.fetchone()
        
        return dict(resumo) if resumo else {}
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/relatorios/performance", tags=["üìä Relat√≥rios"])
def relatorio_performance(limit: int = 50, user_data: dict = Depends(verify_token)):
    """Relat√≥rio de performance (GMD)"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT * FROM vw_performance_animais 
            ORDER BY gmd DESC 
            LIMIT %s
        """, (limit,))
        
        performance = cur.fetchall()
        
        return {
            "total": len(performance),
            "data": [dict(p) for p in performance]
        }
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE MOVIMENTA√á√ïES ====================

@app.post("/api/movimentacoes", tags=["üì¶ Movimenta√ß√µes"], status_code=status.HTTP_201_CREATED)
def registrar_movimentacao(
    movimentacao: MovimentacaoCreate,
    user_data: dict = Depends(verify_token)
):
    """Registra movimenta√ß√£o de animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        data_mov = movimentacao.data_movimentacao or datetime.now().date().isoformat()
        
        cur.execute("""
            INSERT INTO movimentacoes (
                animal_id, tipo, origem, destino, motivo, responsavel, data_movimentacao
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            movimentacao.animal_id, movimentacao.tipo, movimentacao.origem,
            movimentacao.destino, movimentacao.motivo, movimentacao.responsavel,
            data_mov
        ))
        
        mov_id = cur.fetchone()['id']
        
        # Atualiza pasto/lote do animal se aplic√°vel
        if movimentacao.tipo == 'troca_pasto' and movimentacao.destino:
            cur.execute("""
                UPDATE animais 
                SET pasto = %s 
                WHERE id = %s
            """, (movimentacao.destino, movimentacao.animal_id))
        
        elif movimentacao.tipo == 'troca_lote' and movimentacao.destino:
            cur.execute("""
                UPDATE animais 
                SET lote = %s 
                WHERE id = %s
            """, (movimentacao.destino, movimentacao.animal_id))
        
        conn.commit()
        
        return {"id": mov_id, "message": "Movimenta√ß√£o registrada com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS AUXILIARES ====================

@app.get("/api/lotes", tags=["üìç Lotes e Pastos"])
def listar_lotes(user_data: dict = Depends(verify_token)):
    """Lista todos os lotes"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT l.*, COUNT(a.id) as total_animais
            FROM lotes l
            LEFT JOIN animais a ON l.nome = a.lote AND a.status = 'ativo'
            WHERE l.status = 'ativo'
            GROUP BY l.id
            ORDER BY l.nome
        """)
        
        lotes = cur.fetchall()
        
        return {
            "total": len(lotes),
            "data": [dict(l) for l in lotes]
        }
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/pastos", tags=["üìç Lotes e Pastos"])
def listar_pastos(user_data: dict = Depends(verify_token)):
    """Lista todos os pastos"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT p.*, COUNT(a.id) as total_animais
            FROM pastos p
            LEFT JOIN animais a ON p.nome = a.pasto AND a.status = 'ativo'
            GROUP BY p.id
            ORDER BY p.nome
        """)
        
        pastos = cur.fetchall()
        
        return {
            "total": len(pastos),
            "data": [dict(p) for p in pastos]
        }
    
    finally:
        cur.close()
        conn.close()



# ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
# NOVOS ENDPOINTS v2.0 - SISTEMA REPRODUTIVO
# ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

# ============================================================
# RA√áAS
# ============================================================

@app.get("/api/racas", tags=["üß¨ Ra√ßas"])
async def listar_racas(ativo: Optional[bool] = None):
    """Listar todas as ra√ßas cadastradas"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        query = "SELECT id, nome, descricao, origem, ativo, created_at FROM racas"
        if ativo is not None:
            query += f" WHERE ativo = {ativo}"
        query += " ORDER BY nome"
        cur.execute(query)
        racas = cur.fetchall()
        return [{"id": r[0], "nome": r[1], "descricao": r[2], "origem": r[3], 
                 "ativo": r[4], "created_at": r[5]} for r in racas]
    finally:
        cur.close()
        conn.close()

@app.post("/api/racas", tags=["üß¨ Ra√ßas"], status_code=status.HTTP_201_CREATED)
async def criar_raca(nome: str, descricao: Optional[str] = None, 
                     origem: Optional[str] = None):
    """Cadastrar nova ra√ßa"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            INSERT INTO racas (nome, descricao, origem)
            VALUES (%s, %s, %s)
            RETURNING id, nome, descricao, origem, ativo, created_at
        """, (nome, descricao, origem))
        raca = cur.fetchone()
        conn.commit()
        return {"id": raca[0], "nome": raca[1], "descricao": raca[2], 
                "origem": raca[3], "ativo": raca[4], "created_at": raca[5]}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ============================================================
# LOTES
# ============================================================

@app.get("/api/lotes", tags=["üìç Lotes e Pastos"])
async def listar_lotes_v2():
    """Listar lotes cadastrados (v2)"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT l.id, l.nome, l.descricao, l.capacidade, l.ativo,
                   COUNT(a.id) as total_animais
            FROM lotes l
            LEFT JOIN animais a ON a.lote_id = l.id AND a.status = 'ativo'
            GROUP BY l.id, l.nome, l.descricao, l.capacidade, l.ativo
            ORDER BY l.nome
        """)
        lotes = cur.fetchall()
        return [{"id": l[0], "nome": l[1], "descricao": l[2], "capacidade": l[3],
                 "ativo": l[4], "total_animais": l[5]} for l in lotes]
    finally:
        cur.close()
        conn.close()

@app.post("/api/lotes-v2", tags=["üìç Lotes e Pastos"], status_code=status.HTTP_201_CREATED)
async def criar_lote(nome: str, descricao: Optional[str] = None, 
                     capacidade: Optional[int] = None):
    """Cadastrar novo lote"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            INSERT INTO lotes (nome, descricao, capacidade)
            VALUES (%s, %s, %s)
            RETURNING id, nome, descricao, capacidade, ativo, created_at
        """, (nome, descricao, capacidade))
        lote = cur.fetchone()
        conn.commit()
        return {"id": lote[0], "nome": lote[1], "descricao": lote[2],
                "capacidade": lote[3], "ativo": lote[4], "created_at": lote[5]}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ============================================================
# PASTOS
# ============================================================

@app.get("/api/pastos", tags=["üìç Lotes e Pastos"])
async def listar_pastos_v2():
    """Listar pastos cadastrados (v2)"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT p.id, p.nome, p.area_hectares, p.tipo, p.descricao, p.ativo,
                   COUNT(a.id) as total_animais
            FROM pastos p
            LEFT JOIN animais a ON a.pasto_id = p.id AND a.status = 'ativo'
            GROUP BY p.id, p.nome, p.area_hectares, p.tipo, p.descricao, p.ativo
            ORDER BY p.nome
        """)
        pastos = cur.fetchall()
        return [{"id": p[0], "nome": p[1], "area_hectares": float(p[2]) if p[2] else None,
                 "tipo": p[3], "descricao": p[4], "ativo": p[5], "total_animais": p[6]} 
                for p in pastos]
    finally:
        cur.close()
        conn.close()

@app.post("/api/pastos-v2", tags=["üìç Lotes e Pastos"], status_code=status.HTTP_201_CREATED)
async def criar_pasto(nome: str, area_hectares: Optional[float] = None,
                      tipo: Optional[str] = None, descricao: Optional[str] = None):
    """Cadastrar novo pasto"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            INSERT INTO pastos (nome, area_hectares, tipo, descricao)
            VALUES (%s, %s, %s, %s)
            RETURNING id, nome, area_hectares, tipo, descricao, ativo, created_at
        """, (nome, area_hectares, tipo, descricao))
        pasto = cur.fetchone()
        conn.commit()
        return {"id": pasto[0], "nome": pasto[1], "area_hectares": float(pasto[2]) if pasto[2] else None,
                "tipo": pasto[3], "descricao": pasto[4], "ativo": pasto[5], "created_at": pasto[6]}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ============================================================
# TOUROS
# ============================================================

@app.get("/api/touros", tags=["üêÇ Touros"])
async def listar_touros(ativo: Optional[bool] = None):
    """Listar touros/reprodutores cadastrados"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        query = """
            SELECT t.id, t.brinco, t.nome, r.nome as raca, t.data_nascimento,
                   t.registro, t.ativo, t.observacoes
            FROM touros t
            LEFT JOIN racas r ON t.raca_id = r.id
        """
        if ativo is not None:
            query += f" WHERE t.ativo = {ativo}"
        query += " ORDER BY t.brinco"
        
        cur.execute(query)
        touros = cur.fetchall()
        return [{"id": t[0], "brinco": t[1], "nome": t[2], "raca": t[3],
                 "data_nascimento": t[4], "registro": t[5], "ativo": t[6],
                 "observacoes": t[7]} for t in touros]
    finally:
        cur.close()
        conn.close()

@app.post("/api/touros", tags=["üêÇ Touros"], status_code=status.HTTP_201_CREATED)
async def criar_touro(brinco: str, nome: Optional[str] = None, 
                      raca_id: Optional[int] = None, 
                      data_nascimento: Optional[date] = None,
                      registro: Optional[str] = None, 
                      observacoes: Optional[str] = None):
    """Cadastrar novo touro"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            INSERT INTO touros (brinco, nome, raca_id, data_nascimento, registro, observacoes)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING id, brinco, nome, raca_id, data_nascimento, registro, ativo, observacoes, created_at
        """, (brinco, nome, raca_id, data_nascimento, registro, observacoes))
        touro = cur.fetchone()
        conn.commit()
        return {"id": touro[0], "brinco": touro[1], "nome": touro[2], "raca_id": touro[3],
                "data_nascimento": touro[4], "registro": touro[5], "ativo": touro[6],
                "observacoes": touro[7], "created_at": touro[8]}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()

# ============================================================
# CATEGORIAS
# ============================================================

@app.get("/api/categorias", tags=["üìã Categorias"])
async def listar_categorias():
    """Listar categorias de animais (bezerro, novilha, etc)"""
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    try:
        cur.execute("""
            SELECT id, nome, sexo, idade_min_meses, idade_max_meses, descricao, ordem
            FROM categorias
            ORDER BY ordem
        """)
        cats = cur.fetchall()
        return cats
    finally:
        cur.close()
        conn.close()


# ============================================================
# ENDPOINTS DE EDI√á√ÉO (PUT/DELETE)
# ============================================================

@app.put("/api/racas/{raca_id}", tags=["üß¨ Ra√ßas"])
async def atualizar_raca(raca_id: int, nome: Optional[str] = None, 
                         descricao: Optional[str] = None, 
                         origem: Optional[str] = None,
                         ativo: Optional[bool] = None):
    """Atualizar ra√ßa existente"""
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    try:
        updates = []
        params = []
        if nome is not None:
            updates.append("nome = %s")
            params.append(nome)
        if descricao is not None:
            updates.append("descricao = %s")
            params.append(descricao)
        if origem is not None:
            updates.append("origem = %s")
            params.append(origem)
        if ativo is not None:
            updates.append("ativo = %s")
            params.append(ativo)
        
        if not updates:
            raise HTTPException(400, detail="Nenhum campo para atualizar")
        
        params.append(raca_id)
        query = f"UPDATE racas SET {', '.join(updates)}, updated_at = CURRENT_TIMESTAMP WHERE id = %s RETURNING *"
        cur.execute(query, params)
        raca = cur.fetchone()
        
        if not raca:
            raise HTTPException(404, detail="Ra√ßa n√£o encontrada")
        
        conn.commit()
        return dict(raca)
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        raise HTTPException(400, detail={"error": str(e), "type": "database_error"})
    finally:
        cur.close()
        conn.close()

@app.delete("/api/racas/{raca_id}", tags=["üß¨ Ra√ßas"])
async def desativar_raca(raca_id: int):
    """Desativar ra√ßa (soft delete)"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("UPDATE racas SET ativo = false WHERE id = %s RETURNING id", (raca_id,))
        if not cur.fetchone():
            raise HTTPException(404, detail="Ra√ßa n√£o encontrada")
        conn.commit()
        return {"message": "Ra√ßa desativada com sucesso"}
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        raise HTTPException(400, detail={"error": str(e)})
    finally:
        cur.close()
        conn.close()

@app.put("/api/touros/{touro_id}", tags=["üêÇ Touros"])
async def atualizar_touro(touro_id: int, nome: Optional[str] = None,
                          raca_id: Optional[int] = None,
                          ativo: Optional[bool] = None,
                          observacoes: Optional[str] = None):
    """Atualizar touro existente"""
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    try:
        updates = []
        params = []
        if nome is not None:
            updates.append("nome = %s")
            params.append(nome)
        if raca_id is not None:
            updates.append("raca_id = %s")
            params.append(raca_id)
        if ativo is not None:
            updates.append("ativo = %s")
            params.append(ativo)
        if observacoes is not None:
            updates.append("observacoes = %s")
            params.append(observacoes)
        
        if not updates:
            raise HTTPException(400, detail="Nenhum campo para atualizar")
        
        params.append(touro_id)
        query = f"UPDATE touros SET {', '.join(updates)}, updated_at = CURRENT_TIMESTAMP WHERE id = %s RETURNING *"
        cur.execute(query, params)
        touro = cur.fetchone()
        
        if not touro:
            raise HTTPException(404, detail="Touro n√£o encontrado")
        
        conn.commit()
        return dict(touro)
    except HTTPException:
        raise
    except Exception as e:
        conn.rollback()
        raise HTTPException(400, detail={"error": str(e)})
    finally:
        cur.close()
        conn.close()


# ============================================================
# EVENTOS REPRODUTIVOS
# ============================================================

@app.post("/api/eventos-reprodutivos", tags=["üë∂ Reprodu√ß√£o"], status_code=status.HTTP_201_CREATED)
async def criar_evento_reprodutivo(
    animal_id: int,
    tipo_evento: str,
    data_evento: date,
    touro_id: Optional[int] = None,
    bezerra_id: Optional[int] = None,
    natimorto: bool = False,
    observacoes: Optional[str] = None,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """Registrar evento reprodutivo (IA, parto, diagn√≥stico, etc)"""
    token = credentials.credentials
    usuario_id = verify_token(token)
    
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            INSERT INTO eventos_reprodutivos 
            (animal_id, tipo_evento, data_evento, touro_id, bezerra_id, natimorto, observacoes, usuario_id)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id, animal_id, tipo_evento, data_evento, data_prevista, touro_id, bezerra_id, natimorto, observacoes, created_at
        """, (animal_id, tipo_evento, data_evento, touro_id, bezerra_id, natimorto, observacoes, usuario_id))
        
        evento = cur.fetchone()
        conn.commit()
        
        return {
            "id": evento[0],
            "animal_id": evento[1],
            "tipo_evento": evento[2],
            "data_evento": evento[3],
            "data_prevista": evento[4],
            "touro_id": evento[5],
            "bezerra_id": evento[6],
            "natimorto": evento[7],
            "observacoes": evento[8],
            "created_at": evento[9]
        }
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()

@app.get("/api/eventos-reprodutivos/{animal_id}", tags=["üë∂ Reprodu√ß√£o"])
async def listar_eventos_animal(animal_id: int):
    """Listar hist√≥rico reprodutivo de um animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT er.id, er.tipo_evento, er.data_evento, er.data_prevista,
                   t.brinco as touro, b.brinco as bezerra, er.natimorto, er.observacoes, er.created_at
            FROM eventos_reprodutivos er
            LEFT JOIN touros t ON er.touro_id = t.id
            LEFT JOIN animais b ON er.bezerra_id = b.id
            WHERE er.animal_id = %s
            ORDER BY er.data_evento DESC
        """, (animal_id,))
        
        eventos = cur.fetchall()
        return [{
            "id": e[0],
            "tipo_evento": e[1],
            "data_evento": e[2],
            "data_prevista": e[3],
            "touro": e[4],
            "bezerra": e[5],
            "natimorto": e[6],
            "observacoes": e[7],
            "created_at": e[8]
        } for e in eventos]
    finally:
        cur.close()
        conn.close()

# ============================================================
# ESTAT√çSTICAS REPRODUTIVAS
# ============================================================

@app.get("/api/relatorios/reproducao", tags=["üìä Relat√≥rios"])
async def stats_reproducao():
    """Estat√≠sticas gerais de reprodu√ß√£o"""
    conn = get_db_connection()
    cur = conn.cursor(cursor_factory=RealDictCursor)
    try:
        cur.execute("SELECT * FROM v_stats_reproducao")
        stats = cur.fetchone()
        if not stats:
            return {
                "total_prenhas": 0,
                "total_vazias": 0,
                "total_inseminadas": 0,
                "total_a_diagnosticar": 0,
                "total_recem_paridas": 0,
                "total_femeas_reprodutivas": 0
            }
        return dict(stats)
    finally:
        cur.close()
        conn.close()

@app.get("/api/relatorios/proximos-eventos", tags=["üìä Relat√≥rios"])
async def proximos_eventos(dias: int = 30):
    """Pr√≥ximos eventos (partos, diagn√≥sticos) nos pr√≥ximos N dias"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT id, brinco, nome, tipo_evento, data_evento, data_prevista, dias_restantes, touro
            FROM v_proximos_eventos
            WHERE dias_restantes <= %s
            ORDER BY data_prevista
        """, (dias,))
        
        eventos = cur.fetchall()
        return [{
            "id": e[0],
            "brinco": e[1],
            "nome": e[2],
            "tipo_evento": e[3],
            "data_evento": e[4],
            "data_prevista": e[5],
            "dias_restantes": e[6],
            "touro": e[7]
        } for e in eventos]
    finally:
        cur.close()
        conn.close()

@app.get("/api/femeas-reprodutivas", tags=["üë∂ Reprodu√ß√£o"])
async def listar_femeas_reprodutivas():
    """Listar todas as f√™meas em idade reprodutiva"""
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute("SELECT * FROM v_femeas_reprodutivas ORDER BY brinco")
        femeas = cur.fetchall()
        return [{
            "id": f[0],
            "brinco": f[1],
            "nome": f[2],
            "sexo": f[3],
            "data_nascimento": f[4],
            "idade_meses": f[5],
            "raca": f[6],
            "categoria": f[7],
            "status_reprodutivo": f[8],
            "peso_atual": float(f[9]) if f[9] else None
        } for f in femeas]
    finally:
        cur.close()
        conn.close()



@app.get("/", tags=["‚öôÔ∏è Sistema"])
def root():
    """Endpoint raiz"""
    return {
        "app": "API Controle de Gado",
        "version": "1.0.0",
        "status": "online",
        "docs": "/docs"
    }

@app.get("/health", tags=["‚öôÔ∏è Sistema"])
def health_check():
    """Health check"""
    try:
        conn = get_db_connection()
        conn.close()
        return {"status": "healthy", "database": "connected"}
    except:
        return {"status": "unhealthy", "database": "disconnected"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
