"""
API REST para Sistema de Controle de Gado de Corte
FastAPI + PostgreSQL
"""

from fastapi import FastAPI, HTTPException, Depends, status, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime, timedelta
import psycopg2
from psycopg2.extras import RealDictCursor
import secrets
import hashlib
import os
from dotenv import load_dotenv

load_dotenv()

# Configuração do FastAPI
app = FastAPI(
    title="API Controle de Gado",
    description="API REST para gerenciamento de gado de corte",
    version="1.0.0"
)

# CORS para permitir acesso do mobile
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Em produção, especificar domínios
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

security = HTTPBearer()

# Configurações do banco de dados
DB_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': os.getenv('DB_PORT', '5432'),
    'database': os.getenv('DB_NAME', 'controle_gado'),
    'user': os.getenv('DB_USER', 'postgres'),
    'password': os.getenv('DB_PASSWORD', 'postgres')
}

# ==================== MODELOS PYDANTIC ====================

class LoginRequest(BaseModel):
    email: str
    senha: str

class LoginResponse(BaseModel):
    token: str
    usuario: dict
    expires_at: str

class AnimalCreate(BaseModel):
    brinco: str
    nome: Optional[str] = None
    sexo: str = Field(..., pattern="^[MF]$")
    raca: Optional[str] = None
    data_nascimento: Optional[str] = None
    peso_nascimento: Optional[float] = None
    peso_atual: float
    lote: Optional[str] = None
    pasto: Optional[str] = None
    origem: Optional[str] = None
    valor_compra: Optional[float] = None
    observacoes: Optional[str] = None

class AnimalUpdate(BaseModel):
    nome: Optional[str] = None
    peso_atual: Optional[float] = None
    lote: Optional[str] = None
    pasto: Optional[str] = None
    status: Optional[str] = None
    observacoes: Optional[str] = None

class PesagemCreate(BaseModel):
    animal_id: int
    peso: float
    data_pesagem: Optional[str] = None
    condicao_corporal: Optional[int] = Field(None, ge=1, le=5)
    observacoes: Optional[str] = None

class SanidadeCreate(BaseModel):
    animal_id: int
    tipo: str
    produto: str
    dose: Optional[str] = None
    aplicador: Optional[str] = None
    data_aplicacao: Optional[str] = None
    proxima_aplicacao: Optional[str] = None
    custo: Optional[float] = None
    observacoes: Optional[str] = None

class MovimentacaoCreate(BaseModel):
    animal_id: int
    tipo: str
    origem: Optional[str] = None
    destino: Optional[str] = None
    motivo: Optional[str] = None
    responsavel: Optional[str] = None
    data_movimentacao: Optional[str] = None

# ==================== FUNÇÕES DE BANCO DE DADOS ====================

def get_db_connection():
    """Cria conexão com o banco de dados"""
    try:
        conn = psycopg2.connect(**DB_CONFIG, cursor_factory=RealDictCursor)
        return conn
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro ao conectar no banco: {str(e)}")

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verifica se o token é válido"""
    token = credentials.credentials
    
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT s.*, u.nome, u.email, u.nivel_acesso
            FROM sessoes s
            INNER JOIN usuarios u ON s.usuario_id = u.id
            WHERE s.token = %s 
            AND s.expires_at > NOW()
            AND u.ativo = TRUE
        """, (token,))
        
        sessao = cur.fetchone()
        
        if not sessao:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token inválido ou expirado"
            )
        
        return dict(sessao)
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE AUTENTICAÇÃO ====================

@app.post("/api/auth/login", response_model=LoginResponse)
def login(credentials: LoginRequest):
    """Endpoint de login"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        # Busca usuário
        cur.execute("""
            SELECT id, nome, email, senha_hash, nivel_acesso, ativo
            FROM usuarios
            WHERE email = %s
        """, (credentials.email,))
        
        usuario = cur.fetchone()
        
        if not usuario or not usuario['ativo']:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Credenciais inválidas"
            )
        
        # Verifica senha (em produção usar bcrypt)
        senha_hash = hashlib.sha256(credentials.senha.encode()).hexdigest()
        
        if usuario['senha_hash'] != senha_hash:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Credenciais inválidas"
            )
        
        # Gera token
        token = secrets.token_urlsafe(32)
        expires_at = datetime.now() + timedelta(days=30)
        
        # Salva sessão
        cur.execute("""
            INSERT INTO sessoes (usuario_id, token, expires_at)
            VALUES (%s, %s, %s)
            RETURNING id
        """, (usuario['id'], token, expires_at))
        
        conn.commit()
        
        # Atualiza último acesso
        cur.execute("""
            UPDATE usuarios 
            SET ultimo_acesso = NOW() 
            WHERE id = %s
        """, (usuario['id'],))
        
        conn.commit()
        
        return {
            "token": token,
            "usuario": {
                "id": usuario['id'],
                "nome": usuario['nome'],
                "email": usuario['email'],
                "nivel_acesso": usuario['nivel_acesso']
            },
            "expires_at": expires_at.isoformat()
        }
    
    finally:
        cur.close()
        conn.close()

@app.post("/api/auth/logout")
def logout(user_data: dict = Depends(verify_token)):
    """Endpoint de logout"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            DELETE FROM sessoes 
            WHERE usuario_id = %s
        """, (user_data['usuario_id'],))
        
        conn.commit()
        
        return {"message": "Logout realizado com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE ANIMAIS ====================

@app.get("/api/animais")
def listar_animais(
    status: Optional[str] = "ativo",
    lote: Optional[str] = None,
    pasto: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
    user_data: dict = Depends(verify_token)
):
    """Lista animais com filtros"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        query = "SELECT * FROM vw_rebanho_ativo WHERE 1=1"
        params = []
        
        if status:
            query += " AND status = %s"
            params.append(status)
        
        if lote:
            query += " AND lote = %s"
            params.append(lote)
        
        if pasto:
            query += " AND pasto = %s"
            params.append(pasto)
        
        query += " ORDER BY brinco LIMIT %s OFFSET %s"
        params.extend([limit, offset])
        
        cur.execute(query, params)
        animais = cur.fetchall()
        
        return {
            "total": len(animais),
            "data": [dict(animal) for animal in animais]
        }
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/animais/{animal_id}")
def buscar_animal(animal_id: int, user_data: dict = Depends(verify_token)):
    """Busca animal por ID"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT * FROM vw_rebanho_ativo WHERE id = %s", (animal_id,))
        animal = cur.fetchone()
        
        if not animal:
            raise HTTPException(status_code=404, detail="Animal não encontrado")
        
        return dict(animal)
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/animais/brinco/{brinco}")
def buscar_animal_por_brinco(brinco: str, user_data: dict = Depends(verify_token)):
    """Busca animal por número do brinco"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT * FROM vw_rebanho_ativo WHERE brinco = %s", (brinco,))
        animal = cur.fetchone()
        
        if not animal:
            raise HTTPException(status_code=404, detail="Animal não encontrado")
        
        return dict(animal)
    
    finally:
        cur.close()
        conn.close()

@app.post("/api/animais", status_code=status.HTTP_201_CREATED)
def cadastrar_animal(animal: AnimalCreate, user_data: dict = Depends(verify_token)):
    """Cadastra novo animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            INSERT INTO animais (
                brinco, nome, sexo, raca, data_nascimento, peso_nascimento,
                peso_atual, lote, pasto, origem, valor_compra, observacoes
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            animal.brinco, animal.nome, animal.sexo, animal.raca,
            animal.data_nascimento, animal.peso_nascimento, animal.peso_atual,
            animal.lote, animal.pasto, animal.origem, animal.valor_compra,
            animal.observacoes
        ))
        
        animal_id = cur.fetchone()['id']
        conn.commit()
        
        # Registra pesagem inicial
        cur.execute("""
            INSERT INTO pesagens (animal_id, peso, observacoes)
            VALUES (%s, %s, %s)
        """, (animal_id, animal.peso_atual, 'Pesagem inicial - cadastro'))
        
        conn.commit()
        
        return {"id": animal_id, "message": "Animal cadastrado com sucesso"}
    
    except psycopg2.IntegrityError as e:
        conn.rollback()
        if 'unique' in str(e).lower():
            raise HTTPException(status_code=400, detail="Brinco já cadastrado")
        raise HTTPException(status_code=400, detail=str(e))
    
    finally:
        cur.close()
        conn.close()

@app.put("/api/animais/{animal_id}")
def atualizar_animal(
    animal_id: int,
    animal: AnimalUpdate,
    user_data: dict = Depends(verify_token)
):
    """Atualiza dados do animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        # Monta query dinâmica com campos não nulos
        updates = []
        params = []
        
        for field, value in animal.dict(exclude_unset=True).items():
            if value is not None:
                updates.append(f"{field} = %s")
                params.append(value)
        
        if not updates:
            raise HTTPException(status_code=400, detail="Nenhum campo para atualizar")
        
        params.append(animal_id)
        query = f"UPDATE animais SET {', '.join(updates)} WHERE id = %s"
        
        cur.execute(query, params)
        conn.commit()
        
        if cur.rowcount == 0:
            raise HTTPException(status_code=404, detail="Animal não encontrado")
        
        return {"message": "Animal atualizado com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE PESAGENS ====================

@app.get("/api/pesagens/{animal_id}")
def listar_pesagens(animal_id: int, user_data: dict = Depends(verify_token)):
    """Lista pesagens de um animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT * FROM pesagens 
            WHERE animal_id = %s 
            ORDER BY data_pesagem DESC
        """, (animal_id,))
        
        pesagens = cur.fetchall()
        
        return {
            "total": len(pesagens),
            "data": [dict(p) for p in pesagens]
        }
    
    finally:
        cur.close()
        conn.close()

@app.post("/api/pesagens", status_code=status.HTTP_201_CREATED)
def registrar_pesagem(pesagem: PesagemCreate, user_data: dict = Depends(verify_token)):
    """Registra nova pesagem"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        data_pesagem = pesagem.data_pesagem or datetime.now().date().isoformat()
        
        cur.execute("""
            INSERT INTO pesagens (
                animal_id, peso, data_pesagem, condicao_corporal, observacoes
            ) VALUES (%s, %s, %s, %s, %s)
            RETURNING id
        """, (
            pesagem.animal_id, pesagem.peso, data_pesagem,
            pesagem.condicao_corporal, pesagem.observacoes
        ))
        
        pesagem_id = cur.fetchone()['id']
        
        # Atualiza peso atual do animal
        cur.execute("""
            UPDATE animais 
            SET peso_atual = %s 
            WHERE id = %s
        """, (pesagem.peso, pesagem.animal_id))
        
        conn.commit()
        
        return {"id": pesagem_id, "message": "Pesagem registrada com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE SANIDADE ====================

@app.post("/api/sanidade", status_code=status.HTTP_201_CREATED)
def registrar_sanidade(sanidade: SanidadeCreate, user_data: dict = Depends(verify_token)):
    """Registra aplicação de sanidade"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        data_aplicacao = sanidade.data_aplicacao or datetime.now().date().isoformat()
        
        cur.execute("""
            INSERT INTO sanidade (
                animal_id, tipo, produto, dose, aplicador,
                data_aplicacao, proxima_aplicacao, custo, observacoes
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            sanidade.animal_id, sanidade.tipo, sanidade.produto, sanidade.dose,
            sanidade.aplicador, data_aplicacao, sanidade.proxima_aplicacao,
            sanidade.custo, sanidade.observacoes
        ))
        
        sanidade_id = cur.fetchone()['id']
        conn.commit()
        
        return {"id": sanidade_id, "message": "Sanidade registrada com sucesso"}
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/sanidade/proximas")
def listar_proximas_aplicacoes(dias: int = 30, user_data: dict = Depends(verify_token)):
    """Lista próximas aplicações programadas"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT * FROM vw_aplicacoes_proximas 
            WHERE dias_restantes <= %s
            ORDER BY proxima_aplicacao
        """, (dias,))
        
        aplicacoes = cur.fetchall()
        
        return {
            "total": len(aplicacoes),
            "data": [dict(a) for a in aplicacoes]
        }
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE RELATÓRIOS ====================

@app.get("/api/relatorios/resumo")
def relatorio_resumo(user_data: dict = Depends(verify_token)):
    """Relatório resumo do rebanho"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("SELECT * FROM vw_resumo_rebanho")
        resumo = cur.fetchone()
        
        return dict(resumo) if resumo else {}
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/relatorios/performance")
def relatorio_performance(limit: int = 50, user_data: dict = Depends(verify_token)):
    """Relatório de performance (GMD)"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT * FROM vw_performance_animais 
            ORDER BY gmd DESC 
            LIMIT %s
        """, (limit,))
        
        performance = cur.fetchall()
        
        return {
            "total": len(performance),
            "data": [dict(p) for p in performance]
        }
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS DE MOVIMENTAÇÕES ====================

@app.post("/api/movimentacoes", status_code=status.HTTP_201_CREATED)
def registrar_movimentacao(
    movimentacao: MovimentacaoCreate,
    user_data: dict = Depends(verify_token)
):
    """Registra movimentação de animal"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        data_mov = movimentacao.data_movimentacao or datetime.now().date().isoformat()
        
        cur.execute("""
            INSERT INTO movimentacoes (
                animal_id, tipo, origem, destino, motivo, responsavel, data_movimentacao
            ) VALUES (%s, %s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (
            movimentacao.animal_id, movimentacao.tipo, movimentacao.origem,
            movimentacao.destino, movimentacao.motivo, movimentacao.responsavel,
            data_mov
        ))
        
        mov_id = cur.fetchone()['id']
        
        # Atualiza pasto/lote do animal se aplicável
        if movimentacao.tipo == 'troca_pasto' and movimentacao.destino:
            cur.execute("""
                UPDATE animais 
                SET pasto = %s 
                WHERE id = %s
            """, (movimentacao.destino, movimentacao.animal_id))
        
        elif movimentacao.tipo == 'troca_lote' and movimentacao.destino:
            cur.execute("""
                UPDATE animais 
                SET lote = %s 
                WHERE id = %s
            """, (movimentacao.destino, movimentacao.animal_id))
        
        conn.commit()
        
        return {"id": mov_id, "message": "Movimentação registrada com sucesso"}
    
    finally:
        cur.close()
        conn.close()

# ==================== ENDPOINTS AUXILIARES ====================

@app.get("/api/lotes")
def listar_lotes(user_data: dict = Depends(verify_token)):
    """Lista todos os lotes"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT l.*, COUNT(a.id) as total_animais
            FROM lotes l
            LEFT JOIN animais a ON l.nome = a.lote AND a.status = 'ativo'
            WHERE l.status = 'ativo'
            GROUP BY l.id
            ORDER BY l.nome
        """)
        
        lotes = cur.fetchall()
        
        return {
            "total": len(lotes),
            "data": [dict(l) for l in lotes]
        }
    
    finally:
        cur.close()
        conn.close()

@app.get("/api/pastos")
def listar_pastos(user_data: dict = Depends(verify_token)):
    """Lista todos os pastos"""
    conn = get_db_connection()
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT p.*, COUNT(a.id) as total_animais
            FROM pastos p
            LEFT JOIN animais a ON p.nome = a.pasto AND a.status = 'ativo'
            GROUP BY p.id
            ORDER BY p.nome
        """)
        
        pastos = cur.fetchall()
        
        return {
            "total": len(pastos),
            "data": [dict(p) for p in pastos]
        }
    
    finally:
        cur.close()
        conn.close()

@app.get("/")
def root():
    """Endpoint raiz"""
    return {
        "app": "API Controle de Gado",
        "version": "1.0.0",
        "status": "online",
        "docs": "/docs"
    }

@app.get("/health")
def health_check():
    """Health check"""
    try:
        conn = get_db_connection()
        conn.close()
        return {"status": "healthy", "database": "connected"}
    except:
        return {"status": "unhealthy", "database": "disconnected"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
